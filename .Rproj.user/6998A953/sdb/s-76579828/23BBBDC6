{
    "contents" : "---\ntitle: \"Data Manipulaton\"\noutput:\n  html_document:\n    css: ~/GitHub/Longitudinal_Models_of_Religiosity_NLSY97/www/css/thesis.css\n    fig.retina: 2\n    fig_width: 8\n    toc: yes\n    theme: united\n  md_document:\n    toc: yes\n    toc_depth: 3\n  pdf_document:\n    fig_caption: no\n    fig_crop: no\n    fig_width: 8\n    latex_engine: xelatex\n    number_sections: yes\n    toc: yes\n    toc_depth: 3\n  word_document:\n    fig_width: 6.5\nmainfont: Calibri\n---\n\n\n<!--  Set the working directory to the repository's base directory; this assumes the report is nested inside of only one directory.-->\n```{r, echo=F, message=F} \nrequire(knitr)\nopts_knit$set(root.dir='../../')  #Don't combine this call with any other chunk -especially one that uses file paths.\n\n```\n\n```{r set_options, echo=F, message=F}\nrequire(knitr)\n# getwd()\nopts_chunk$set(\n  results='show', \n  message = TRUE,\n  comment = NA, \n  tidy = FALSE,\n#   fig.height = 4.8, \n#   fig.width = 6.5, \n#   out.width = \"550px\",\n  fig.path = 'figure_rmd/automatic_report/',     \n  dev = \"png\",\n#   fig.path = 'figure_pdf/',     \n#   dev = \"pdf\",\n  dpi = 400\n)\nechoChunks <- FALSE\nwarningChunks<- FALSE\noptions(width=120) #So the output is 50% wider than the default.\nread_chunk(\"./Vignettes/dplyr/using_dplyr.R\") # the file to which knitr calls for the chunks\n```\n\n\nDemonstrating the language of data manipulation in <code>dplyr</code> packages using  **dsL** as an example\n\n<!-- Run this three chunks to get to the starting point -->\n```{r DeclareGlobals, echo=echoChunks, message=FALSE}\n```\n\n```{r LoadPackages, echo=echoChunks, message=F}\n```\n\n```{r LoadData, echo=echoChunks, message=FALSE}\n```\n\n\n## Five basic functions in data handling\n\nFor a more detailed discussion of basic verbs and operations consult the [R-Studio guide][1] or internal [vignette][2]\n```{r,eval=FALSE}\nvignette(\"introduction\",package=\"dplyr\")\n```\n\nThe following is a brief demonstration of <code>dplyr</code> syntax using **dsL** dataset as an example. I attach prefix <code>dplyr::</code> to avoid possible conflicts with <code>plyr</code> package on which <code>ggplot2</code> package relies. I recommend such practice in all <code>dplyr</code>  expressions in sharable publications.  \n\nOne of the innovations in <code>dplyr</code> is the ability to chain phrases in the data manipulationsentence. The operator <code>%>%</code> (or <code>%.%</code>), accomplishes this, turning <code>x %>% f(y)</code> into <code>f(x, y) </code>.   \n\n\n###<code>select()</code> \nselects variables into a smaller data set\n```{r}\nds<-dsL\ndim(ds)\nds<- dsL %>%\n  dplyr::select(id,year, byear, attend, attendF)\nhead(ds,13)\ndim(ds)\n```\n\n###<code>filter()</code> \nRemoves observations that do not meet criteria. The following code selects observation based on the type of sample    \n\n```{r, echo=F}\nds<- dsL %>%\n  dplyr::filter(id %in% c(1, 6803) & year==2000 ) %>%\n  dplyr::select(sample, sampleF)\nds\n```\nand only between years 2000 and 2011, as only during those years the outcome of interest <code>attend</code> was recorded. \n```{r, echo=T, message=F}\nds<- dsL %>%\n  dplyr::filter(sample==1, year %in% c(2000:2011))%>%\n  dplyr::select(id, year, attend, attendF)\nhead(ds,13)\n```\n\n\n###<code>arrange()</code> \nSorts observations\n```{r, echo=T, message=F}\nds<- dsL %>%\n  dplyr::filter(sample==1, year %in% c(2000:2011)) %>%\n  dplyr::select(id, year, attend) %>%\n  dplyr::arrange(year, desc(id))\nhead(ds,13)\nds<- dplyr::arrange(ds, id, year)\nhead(ds, 13)\n```\n\n\n###<code>mutate()</code> \n\nCreates additional variables from the values of existing.\n```{r, echo=T, message=F}\nds<- dsL %>%\n  dplyr::filter(sample==1, year %in% c(2000:2011)) %>%\n  dplyr::select(id, byear, year, attend) %>%\n  dplyr::mutate(age = year-byear, \n                timec = year-2000,\n                linear= timec,\n                quadratic= linear^2,\n                cubic= linear^3)\nhead(ds,13)\n```\n\n###<code>summarize()</code> \ncollapses data into a single value computed according to the aggregate functions.\n\n\n```{r}\nrequire(dplyr)\nds<- dsL %>%\n  dplyr::filter(sample==1) %>%\n  dplyr::summarize(N= n_distinct(id))\nds\n```\nOther functions one could use with <code>summarize()</code> include:\n\nFrom <code>base</code>   \n\n+ <code> min() </code>   \n+ <code> max() </code>   \n+ <code> mean() </code>   \n+ <code> sum() </code>   \n+ <code> sd() </code>   \n+ <code> median() </code>   \n+ <code> IQR()  </code>   \n\nNative to <code>dplyr</code>    \n\n+ <code> n() </code>  -  number of observations in the current group   \n+ <code> n_distinct(x) </code>  -    count the number of unique values in x.    \n+ <code> first(x) </code>  -  similar to <code>x[ 1 ]</code> + control over <code>NA</code>      \n+ <code> last(x) </code>  -  similar to <code>x[length(x)] </code> + control over <code>NA</code>      \n+ <code> nth(x, n)  </code>  -  similar to<code> x[n] </code>  + control over <code>NA</code>     \n\n## Grouping and Combining \nThe function <code>group_by()</code> is used to identify groups in split-apply-combine (SAC) procedure: it splits the initial data into smaller datasets (according to all possible interactions between the levels of supplied variables). It is these smaller datasets that <code>summarize()</code> will individually collapse into a single computed value according to its formula.  \n```{r, echo=T, message=F}\nds<- dsL %>%\n  dplyr::filter(sample==1, year %in% c(2000:2011)) %>%\n  dplyr::select(id, year, attendF) %>%\n  dplyr::group_by(year,attendF) %>%\n  dplyr::summarise(count = n()) %>%\n  dplyr::mutate(total = sum(count),\n              percent= count/total)\nhead(ds,10)\n\n```\n\nTo verify :\n```{r, echo=T, message=F}\ndplyr::summarize( filter(ds, year==2000), should.be.one=sum(percent))\n```\n\n\n## Base subsetting\nGenerally, we can compose any desired dataset by using matrix calls. The general formula is of the form:\n**ds**[  _rowCond_  ,  _colCond_  ], where **ds** is a dataframe, and  _rowCond_ and _colCond_ are conditions for including rows and columns of the new dataset, respectively. One can also call a variable by attaching <code> $ </code> followed variable name to the name of the dataset:    <code>**ds**_$variableName_</code>. \n```{r, echo=T}\nds<-dsL[dsL$year %in% c(2000:2011),c('id',\"byear\",\"year\",\"agemon\",\"attendF\",\"ageyearF\")]\nprint(ds[ds$id==1,]) \n```\n\nThe following is a list of operatiors that can be used in these calls. \n<ul>\n<li>basic math operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%%</code>, <code>^</code></li>\n<li>math functions: <code>abs</code>, <code>acos</code>, <code>acosh</code>, <code>asin</code>, <code>asinh</code>, <code>atan</code>, <code>atan2</code>,\n<code>atanh</code>, <code>ceiling</code>, <code>cos</code>, <code>cosh</code>, <code>cot</code>, <code>coth</code>, <code>exp</code>, <code>floor</code>,\n<code>log</code>, <code>log10</code>, <code>round</code>, <code>sign</code>, <code>sin</code>, <code>sinh</code>, <code>sqrt</code>, <code>tan</code>, <code>tanh</code></li>\n<li>logical comparisons: <code>&lt;</code>, <code>&lt;=</code>, <code>!=</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>==</code>, <code>%in%</code></li>\n<li>boolean operations: <code>&amp;</code>, <code>&amp;&amp;</code>, <code>|</code>, <code>||</code>, <code>!</code>, <code>xor</code></li>\n<li>basic aggregations: <code>mean</code>, <code>sum</code>, <code>min</code>, <code>max</code>, <code>sd</code>, <code>var</code></li>\n</ul>\n\n<code>dplyr</code> can translate all of these into SQL. For more of on <code>dplyr</code> and SQL compatibility consult another built-in [vignette][3]\n```{r,eval=FALSE}\nvignette(\"database\",package=\"dplyr\")\n```\n\n## Base Reference\n\nThe following unary and binary operators are defined for <code> base</code>. They are listed in precedence groups, from highest to lowest.\n\n\n+ <code> :: :::   </code> -  access variables in a namespace  \n+ <code> $ @\t    </code> - component / slot extraction   \n+ <code> [ [[\t    </code> - indexing  \n+ <code> ^\t      </code>  - exponentiation (right to left)   \n+ <code> - +\t </code>  - unary minus and plus   \n+ <code> :\t </code>  - sequence operator   \n+ <code> %any%\t </code>  - special operators (including %% and %/%)   \n+ <code> * /\t </code>  - multiply, divide   \n+ <code> + -\t </code>  - (binary) add, subtract   \n+ <code> < > <= >= == !=\t </code>  - ordering and comparison   \n+ <code> !\t </code>  - negation   \n+ <code> & &&\t </code>  - and   \n+ <code> | ||\t </code>  - or   \n+ <code> ~\t </code>  - as in formulae   \n+ <code> -> ->>\t </code>  - rightwards assignment   \n+ <code> <- <<-\t </code>  - assignment (right to left)   \n+ <code> =\t </code>  - assignment (right to left)   \n+ <code> ?\t </code>  - help (unary and binary)   \n\n\n## Read more \n\nin <code>./Models/Descriptives</code>:   \n\n+ [Metrics][metrics] - how values of items are labeled       \n+ [Descriptives][descriptives] - basic stats of various items       \n+ [Attendance][attend] - focus on church attendence over time      \n+ [Databox][databox]        \n\nSee also   \n\n+ [Deriving Data from NLYS97 extract][derive]\n+ [Data Manipulation Guide][manipulate]\n\n\n```{r child, child = '../../Models/Descriptives/Citations.Rmd'}\n\n```\n\n\n[1]:http://blog.rstudio.org/2014/01/17/introducing-dplyr/\n[2]:http://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html\n[3]:http://cran.rstudio.com/web/packages/dplyr/vignettes/databases.html\n",
    "created" : 1404087203517.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1937282689",
    "id" : "23BBBDC6",
    "lastKnownWriteTime" : 1404105897,
    "path" : "~/GitHub/Longitudinal_Models_of_Religiosity_NLSY97/Vignettes/dplyr/Data_Manipulation_Guide.Rmd",
    "project_path" : "Vignettes/dplyr/Data_Manipulation_Guide.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}